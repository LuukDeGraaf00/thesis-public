\section{Extra}

\paragraph{Implementation}

Accelerate\cite{accelerate-sum-types} and Futhark\cite{futhark-sum-types} are functional array languages that support 

\paragraph{C/C++}

An union is a structure identical to the largest member of the union.
Accessing a member of the union extracts the raw value out of the union, independent of the last assigned variant.
This makes using unions inherently not type-safe to use.
The variant class template partly solves this by attaching a tag and throwing a runtime error when accessing a variant that was not assigned.

\paragraph{Haskell}

sum type / instances

\paragraph{Dynamic programming languages}

\paragraph{Entity-Component-System}

Systems are top-level functions that operate on all entities that contain a set of components. 
An entity is idiomatically a set of components, but instantiated as a globally unique index that can identify the associated data components.
Rather than iterating with this index, systems utilize the implicit structure of an entity to directly iterate on the data components.  
The 'type' of an entity can be modified by removing or adding components.

The ECS pattern is arguably a reaction to the prevalence of object-oriented languages within game engines.
The premise is to organizes game-logic within systems rather than components, where the relation between components is flexible\cite{ecs-origin}.
In contrast to inheritance, where relations are statically determined and game-logic is embedded within an hierarchy.
In this chapter the type interpretation of entities is discussed, and linked to functional languages.

An entity is fundamentally a composition of components, irrespective of which components can be combined.
As many object-oriented languages are nominally typed, an entity is often implemented to only have one component of each.
This means an entity is effectively a {\it set} of components.
Systems operate on all entities that contain such a set of components, where components are {\it mutated}.
Structural changes to entities are invoked through statements.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.2]{ecs}
    \caption{ conceptual entity-component-system representation of systems }
\end{figure}

The ECS design pattern is arguably inherently imperative, due to prevalence of mutating state. 
Apecs, an ECS implementation in Haskell, achieves this imperative style through monads\cite{ecs-apecs}.
All these considerations are related to the interpretation of the relation between components, in essence the {\it type} of an entity. 
Rather than emulating ECS, existing type systems can be used to handle the relation between data.

Apecs\cite{ecs-apecs} is an ECS library in Haskell, with experimental support for concurrency through the Software Transactional Memory (STM) monad\cite{STM-monad}.
The STM monad utilizes atomic instructions to achieve concurrency within a monadic context.
Entities are stored with an integer dictionary, but can be explicitly stored in a sparse fixed size {\it cache} which allows for constant access time. 

Specs is an ECS library in Rust\cite{ecs-specs}, with native support for parallelism.
It supports several storages such as: a tree data structure, dense vector, sparse vector and an hashmap.
Iteration on entities is done by specifying the relation between the components: join, optional and excluded.
An entity can be {\it flagged} (tag) to denote events such as the destruction of the entity.

Unity is a game-engine which released their production ready Data-Oriented-Tech-Stack (DOTS) in 2022, which centres around an ECS implementation which they have patented\cite{unity-ecs-patent}.
It uses LLVM to optimize and vectorize C\# code (burst compiler) and has access to their internal c++ library for parallel and concurrent tasks (job system).
The ECS implementation heavily employs the .NET Compiler Platform Roslyn to generate source-code for iterations on user-defined datatypes.
An \type{Entity} is idiomatically a composite datatype but implemented as an \type{identifier} with a \type{version}\footnote{Destroying an entity increments the \type{version}, which means copies of entities know they are destroyed and the \type{identifier} can be reused at a later point.}.
A single array keeps track of all entities, without data components.
Each \type{Entity} and related data components are stored in a \type{Chunk}, a fixed size buffer of 16000 bytes, alongside other entities with the same \type{Archetype}\footnote{An \type{ISharedComponent} extends this to the value of a component, which means each value has a unique \type{Chunk} and the value can be stored within the \type{Chunk} header. }.
Instead of pattern matching, a \type{Query} matches on certain properties of entities, such as containing a certain component.
Collective operations, such as a \type{Job}, operate on a \type{Chunk} directly.
Structural changes can be queued in parallel, but create a sync-point when executed and involves entities to be moved between chunks.
This is not required for an \type{IEnableComponent}, which functions as an tagged component akin to the \type{Maybe a} type. 
A notable observation is that delaying structural changes has side-effects as queued structural changes are not taking in account.

paragraph{Code Generation}

A common factor with data type representation is that they are understandably heavily ingrained within a compiler. 
This can make an ergonomic and zero-cost abstraction problematic as a compiler will treat the functionally identical types as distinct.
This can be resolved by generating code dependent on the concrete instantiation of the type. 

\paragraph{Algebraic Data Type}

\paragraph{Accelerate}

Accelerate is a data-parallel array language deeply embedded within Haskell.
An abstract syntax tree (AST) is created and optimized by Accelerate within Haskell's runtime system.
This greatly improves useability, as it can function as an Haskell library, at the cost of executing code within another runtime system.
The garbage collection of the Haskell runtime system is speculated to hinder performance\cite{accelerate-performance}. 
A type-safe interface to the compiler infrastructure LLVM enabled the creation of two backends: GPU and multi-core CPU's\cite{accelerate-llvm}. 
These backends can be used to execute a small set of collective operators in parallel; such as \type{map}, \type{fold} and \type{stencil}. 

\begin{verbatim}

dotp :: Acc (Vector Float) -> Acc (Vector Float) -> Acc (Scalar Float)
dotp xs ys = fold (+) 0 (zipWith (*) xs ys)

\end{verbatim}

The inherit thread-safety and fixed set of collective operators guarantee a consistent application of data-level parallelization.
It in addition allows for these collective operators to be heavily optimized in isolation, but also in relation to other collective operators.
A naive implementation of \type{dotp} would create an intermediate array for the results of the \type{zipWith} function\cite{accelerate-array-fusion}.
Fusing these operations would eliminate an iteration and the intermediate array, at the cost of potential register pressure. 
Accelerate fuses these collective operations, unless the fusion introduces duplicate work or the \type{compute} function is explicitly called.  

As Accelerate is embedded within Haskell, it uses algebraic data types and tuples for composite datatypes.
Datatypes must be {\it lifted} into the abstract syntax tree of Accelerate, which is implemented for all native types.
As algebraic data types are not native, pattern synonyms are used to create an isomorphic mapping {\it at compile-time} between the Haskell and the Accelerate datatype.
As pattern matching cannot be overloaded in Haskell, the \type{match} operator is used to inject the required branching\cite{accelerate-pattern-matching}.

\begin{verbatim}
    
    mkPattern ''Maybe

    apply :: (a -> b) -> Maybe a -> Maybe b
    apply f = match (fmap f)

    fmap :: (a -> b) -> Maybe a -> Maybe b
    fmap f (Just_ a) = Just_ (f a)
    fmap f Nothing_  = Nothing_
    
\end{verbatim}

Currently Accelerate uses a non-compact tagged union representation for sum types.
Research has been done on a compact tagged union representation for parallel arrays, which has been named a {\it Recursive Tagged Union}\cite{accelerate-sum-types}.
The representation uses a unified tag for nested sum types, which optimizes memory usage at the cost of tag (de-)construction.  
It has been partly implemented in Accelerate, and has not yet been benchmarked.

An {\it embedded} language defines its terms and values in a {\it host language}.
\\
There are various degrees of embedding... shallow, deep, combinator, meta, compiler
\\
A problem is embedded pattern matching... as choice elements are evaluated in the host.

\paragraph{C$\lambda$aSH}

A domain-specific language for circuit design that is embedded within Haskell.
Choice elements, such as algebraic data types, only exist as functions outside the syntactic elements of the language.
User-defined types are thus restricted to product types and enumeration types, i.e. a sum type without any fields. \cite{clash}

\paragraph{Lava}

Another domain-specific language for circuit design that is embedded within Haskell.

https://www.haskell.org/haskell-symposium/1999/1999-28.pdf
$https://www.researchgate.net/publication/221562984_Type-safe_observable_sharing_in_Haskell$


\paragraph{Accelerate}

Accelerate is a data-parallel array language deeply embedded within Haskell.
Accelerate internally uses tuples to represent types, which are stored in an struct-of-array fashion.
Sum types are currently represented as a non-compact tagged union.
Research has been done on a compact tagged union representation for parallel arrays, which has been named a {\it Recursive Tagged Union}\cite{accelerate-sum-types}.
The representation uses a unified tag for nested sum types, which optimizes memory usage at the cost of tag (de-)construction.  
It has not yet been implemented in Accelerate.

Futhark is a functional structurally typed data-parallel array language.
Research has been done on including structural sum types to the Futhark compiler\cite{futhark-sum-types}, which has been implemented.
A sum type is flattened to a tuple, which is stored as a struct-of-arrays. 
Identical primitive types are {\it deduplicated} and share the same tuple slot.


As Accelerate is a domain-specific-language within Haskell...

The \type{Elt} type-class (Extract, Load, Transform) defines a mapping between the Haskell and the Accelerate datatype.
This process has been streamlined through a {\it generic} default implementation, which utilizes a standardized mapping.
Functions do not use this process, and instead operate directly on the corresponding datatype.

The ECS design pattern is arguably inherently imperative, due to prevalence of mutating state. 
Apecs, an ECS implementation in Haskell, achieves this imperative style through monads\cite{ecs-apecs}.
All these considerations are related to the interpretation of the relation between components, in essence the {\it type} of an entity. 
Rather than emulating ECS, existing type systems can be used to handle the relation between data.

Apecs\cite{ecs-apecs} is an ECS library in Haskell, with experimental support for concurrency through the Software Transactional Memory (STM) monad\cite{STM-monad}.
The STM monad utilizes atomic instructions to achieve concurrency within a monadic context.
Entities are stored with an integer dictionary, but can be explicitly stored in a sparse fixed size {\it cache} which allows for constant access time. 

Specs is an ECS library in Rust\cite{ecs-specs}, with native support for parallelism.
It supports several storages such as: a tree data structure, dense vector, sparse vector and an hashmap.
Iteration on entities is done by specifying the relation between the components: join, optional and excluded.
An entity can be {\it flagged} (tag) to denote events such as the destruction of the entity.

Unity is a game-engine which released their production ready Data-Oriented-Tech-Stack (DOTS) in 2022, which centres around an ECS implementation which they have patented\cite{unity-ecs-patent}.
It uses LLVM to optimize and vectorize C\# code (burst compiler) and has access to their internal c++ library for parallel and concurrent tasks (job system).
The ECS implementation heavily employs the .NET Compiler Platform Roslyn to generate source-code for iterations on user-defined datatypes.
An \type{Entity} is idiomatically a composite datatype but implemented as an \type{identifier} with a \type{version}\footnote{Destroying an entity increments the \type{version}, which means copies of entities know they are destroyed and the \type{identifier} can be reused at a later point.}.
A single array keeps track of all entities, without data components.
Each \type{Entity} and related data components are stored in a \type{Chunk}, a fixed size buffer of 16000 bytes, alongside other entities with the same \type{Archetype}\footnote{An \type{ISharedComponent} extends this to the value of a component, which means each value has a unique \type{Chunk} and the value can be stored within the \type{Chunk} header. }.
Instead of pattern matching, a \type{Query} matches on certain properties of entities, such as containing a certain component.
Collective operations, such as a \type{Job}, operate on a \type{Chunk} directly.
Structural changes can be queued in parallel, but create a sync-point when executed and involves entities to be moved between chunks.
This is not required for an \type{IEnableComponent}, which functions as an tagged component akin to the \type{Maybe a} type. 
A notable observation is that delaying structural changes has side-effects as queued structural changes are not taking in account.

\paragraph{Motivation}

A generic performant implementation is explored, which can alter between the representations.
An implementation will be done in Accelerate, a data-parallel language embedded within Haskell.

\paragraph{Contributions}
